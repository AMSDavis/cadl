import "@azure-tools/adl-rest";
import "@azure-tools/adl-openapi";
import "@azure-tools/adl-rpaas";

@doc("Reusable representation of an email address")
@format("^[A-Za-z0-9._%+-]+@(?:[A-Za-z0-9-]+\\.)+[A-Za-z]{2,}$")
model email extends string {};

@doc("Shorthand for setting length limit.")
@minLength(5)
@maxLength(50)
model MediumString extends string {}

@doc("Credential string.")
@secret()
model SecureString extends string {}

@doc("Indicates whether metrics are being sent.")
enum SendingMetricsStatus {
  "Enabled",
  "Disabled"
}

@doc("Indicates whether logs are being sent.")
enum SendingLogsStatus {
  "Enabled",
  "Disabled"
}

@doc("Indicates whether AAD logs are being sent.")
enum SendAadLogsStatus {
  "Enabled",
  "Disabled"
}

@doc("Indicates whether activity logs are being sent.")
enum SendActivityLogsStatus {
  "Enabled",
  "Disabled"
}

@doc("Indicates whether subscription logs are being sent.")
enum SendSubscriptionLogsStatus {
  "Enabled",
  "Disabled"
}

// Why is this not represented as a subResource? How are monitored resources added?
//MonitorResource and MontitoredResource are really close together as names, and may cause confusion
// perhaps ObservedResource
@doc("Details of resource being monitored by Dynatrace monitor resource")
model MonitoredResource {
  @doc("The ARM id of the resource.")
  id?: string;

  @doc("Flag indicating if resource is sending metrics to Dynatrace.")
  sendingMetrics?: SendingMetricsStatus;

  @doc("Reason for why the resource is sending metrics (or why it is not sending).")
  reasonForMetricsStatus?: string;

  @doc("Flag indicating if resource is sending logs to Dynatrace.")
  sendingLogs?: SendingLogsStatus;

  @doc("Reason for why the resource is sending logs (or why it is not sending).")
  reasonForLogsStatus?: string; 
}

@doc("List of all the resources being monitored by Dynatrace monitor resource")
model MonitoredResourceListResponse extends Page<MonitoredResource> {}

@doc("Properties specific to the monitor resource.")
model MonitorProperties {
  @doc("Status of the monitor.")
  monitoringStatus?: MonitoringStatus;

  @doc("Marketplace subscription status.")
  marketplaceSubscriptionStatus?: MarketplaceSubscriptionStatus;

  @doc("Properties of the Dynatrace environment.")
  dynatraceEnvironmentProperties?: DynatraceEnvironmentProperties;

  @doc("User info.")
  userInfo?: UserInfo;

  @doc("Billing plan information.")
  planData?: PlanData;

  @visibility("read")
  @doc("Liftr Resource category.")
  liftrResourceCategory?: LiftrResourceCategories;

  @visibility("read")
  @doc("The priority of the resource.")
  liftrResourcePreference?: int32;

  @visibility("read")
	@doc("Provisioning state of the resource.")
	provisioningState?: ProvisioningState;
}

@doc("Properties of the Dynatrace environment.")
model DynatraceEnvironmentProperties {
	@doc("User id")
	@visibility("read")
	userId?: string;

	@doc("Dynatrace Account Information")
	@visibility("read")
	accountInfo?: AccountInfo;

	@doc("Dynatrace Environment Information")
	@visibility("read")
	environmentInfo?: EnvironmentInfo;
}

@doc("Dynatrace Account Information")
model AccountInfo {
	@visibility("read")
	@doc("Account Id of the account this environment is linked to")
	accountId?: string;

	@visibility("read")
	@doc("Region in which the account is created")
	regionId?: string;
}

@doc("Dynatrace account API Key")
model AccountInfoSecure {
  @visibility("read")
	@doc("Account Id of the account this environment is linked to")
	accountId?: string;

	@visibility("read")
	@doc("API Key of the user account")
	apiKey?: SecureString;

	@visibility("read")
	@doc("Region in which the account is created")
	regionId?: string;
}

@doc("Dynatrace Environment Information")
model EnvironmentInfo {
	@visibility("read")
	@doc("Id of the environment created")
	environmentId?: string;

	@visibility("read")
	@doc("Ingestion key of the environment")
	ingestionKey?: string;

	@visibility("read")
	@doc("Ingestion endpoint used for sending logs")
	logsIngestionEndpoint?: string;
}

@doc("Managed identity types")
enum ManagedIdentityTypes { "SystemAssigned", "UserAssigned" }

@doc("Identity properties of the monitor resource.")
model IdentityProperties {
  @doc("The identity ID.")
  @visibility("read")
  principalId?: string;

  @visibility("read")
  @doc("The tenant ID of resource.")
  tenantId?: string;

  @doc("Type of identity")
  type?: ManagedIdentityTypes
}

@doc("Provisioning state of the monitoring resource")
enum ProvisioningState {
  "Accepted", "Creating", "Updating", "Deleting",
  "Succeeded", "Failed", "Canceled", "Deleted", "NotSpecified"
}

@doc("Flag specifying if the resource monitoring is enabled or disabled.")
enum MonitoringStatus { "Enabled", "Disabled" }

@doc("Flag specifying the Marketplace Subscription Status of the resource. If payment is not made in time, the resource will go in Suspended state.")
enum MarketplaceSubscriptionStatus { "Active", "Suspended" }

@doc("Liftr resource category")
enum LiftrResourceCategories { "Unknown", "MonitorLogs" };

@doc("User info.")
model UserInfo {
  @doc("First Name of the user")
  firstName?: MediumString;

  @doc("Last Name of the user")
  lastName?: MediumString;

  @doc("Email of the user used by Dynatrace for contacting them if needed")
  emailAddress?: email;

  @maxLength(40)
  @doc("Phone number of the user used by Dynatrace for contacting them if needed")
  phoneNumber?: string;

  @doc("Country of the user")
  country?: string

}

@doc("Billing plan information.")
model PlanData {
  @doc("different usage type like PAYG/COMMITTED. this could be enum")
  usageType?: MediumString;

  @doc("different billing cycles like MONTHLY/WEEKLY. this could be enum")
  billingCycle?: MediumString;

  @doc("plan id as published by Dynatrace")
  planDetails?: MediumString;

  @doc("date when plan was applied")
  effectiveDate?: zonedDateTime;
}

@doc("Properties for the Tag rules resource of a Monitor account.")
model MonitoringTagRulesProperties {
  @doc("Set of rules for sending logs for the Monitor resource.")
  logRules?: LogRules;

  @visibility("read")
	@doc("Provisioning state of the resource.")
	provisioningState?: ProvisioningState;
}

@doc("Set of rules for sending logs for the Monitor resource.")
model LogRules {
  @doc("Flag specifying if AAD logs should be sent for the Monitor resource.")
  sendAadLogs?: SendAadLogsStatus; // Enabled, Disabled

  @doc("Flag specifying if subscription logs should be sent for the Monitor resource.")
  sendSubscriptionLogs?: SendSubscriptionLogsStatus; // Enabled, Disabled

  @doc("Flag specifying if activity logs from Azure resources should be sent for the Monitor resource.")
  sendActivityLogs?: SendActivityLogsStatus; // Enabled, Disabled

  @doc("""
  List of filtering tags to be used for capturing logs. This only takes effect if SendActivityLogs flag is enabled. If empty, all resources will be captured.
  If only Exclude action is specified, the rules will apply to the list of all available resources. If Include actions are specified, the rules will only include resources with the associated tags.
  """)
  filteringTags?: FilteringTag[];
}

@doc("The definition of a filtering tag. Filtering tags are used for capturing resources and include/exclude them from being monitored.")
model FilteringTag {
  @doc("The name (also known as the key) of the tag.")
  name?: string;
  @doc("The value of the tag.")
  value?: string;
  @doc("Valid actions for a filtering tag. Exclusion takes priority over inclusion.")
  action?: TagAction;
}

@doc("Valid actions for a filtering tag. Exclusion takes priority over inclusion.")
enum TagAction { "Include", "Exclude" }
